<HTML>
<HEAD>
<TITLE>Wavelet</TITLE>
<META name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META name="description" content="&quot;Modelica Wavelet Library&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Wavelet<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet"></A>Wavelet</H2>
<B>Modelica Wavelet Library</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
The package <b>Wavelet</b> is a function library developed for Modelica to carry out wavelet transform and related calculations.
It is used for the post processing of the simulation results or other data. Online operation, meaning execution of the functions 
during the simulation process, is not possible.
</p><p>
The numerical calculation of wavelet transform requires that the data be sampled in equidistant time grids. 
If non-equidistant time grids are used, the data should be firstly converted to equidistant using function 
<A HREF="#Wavelet.General.interpL"
>interpL</a> in this library. If the data are to be generated by Dymola 
with model simulation, it is suggested that <b>Equidistant time grid</b> should be checked in the <b>Simulation</b> window through the menu
 <b>Simulation/Setup.../Output/Output selection</b>.
</p><p>
Most functions in this library do not check the input parameters. It is the task of the user to provide valid parameters. 
Upon wrong input parameters, unexpected errors might occur.
</p><p>
This library is developed and tested with the demo version of Dymola 2013.
</p><p>
<h4><font color="#008000">List of the packages:</font></h4>
<p>Detailed information is to be found in each package.</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>Package</b></td>
      <td><b>Description</b></td>
      </tr>
  
  <tr><td><A HREF="#Wavelet.Examples"
>Examples</a></td> <td>Some examples showing some functionalities of this library</td> </tr>
  <tr><td><A HREF="#Wavelet.MRA"
>MRA</a></td> <td>Wavelet application for multi-resolution analysis (MRA)</td> </tr>
  <tr><td><A HREF="#Wavelet.Denoising"
>Denoising</a></td> <td>Wavelet application for denoising</td> </tr>
  <tr><td><A HREF="#Wavelet.Transform"
>Transform</a></td> <td>Wavelet transform and tightly related functions</td> </tr>
  <tr><td><A HREF="#Wavelet.Families"
>Families</a></td> <td>Definition of wavelet families</td> </tr>
  <tr><td><A HREF="#Wavelet.General"
>General</a></td> <td>General purpose functions used in this library</td> </tr>
  <tr><td><A HREF="#Wavelet.Records"
>Records</a></td> <td>Definitions for supporting graphic user interface</td> </tr>
  <tr><td><A HREF="#Wavelet.Types"
>Types</a></td><td>Definitions of enumeration values </td> </tr>
</table>
</p>

<br>
<h4><font color="#008000">Required libraries:</font></h4>
Besides the Modelica standard conform library, the following libraries are required for using this wavelet library:
</p>
<p style="margin-left: 40px;">
<b>* Modelica_LinearSystems2:</b> This library is used for displaying the curves.<br>
<b>* Plot3D:</b> This is used for showing the images generated by wavelet continuous transform (CWT). 
The library Plot3D is delivered with Dymola. In the Dymola demo version, the functionality of Plot3D 
seems to be limited, such that the 3D surfaces can only be displayed in a 2D manner.
<br><p>

<h4><font color="#008000">License:</font></h4>
<p>All files in this directory (Wavelet) and in all subdirectories, especially all files that build package "Wavelet" 
are released under the <b>Modelica License 2</b>.</p>
</p>
<br>
<h4><font color="#008000">Developers:</font></h4>
<p style="margin-left: 40px;">
Dr. Michael Gao, michael.gao@tum.de<br>
Mr. Qipeng Hu, qipeng.hu@gmail.com<br>
Mr. Weihua Wang<br>
Mr. Hanko Ipach</p>
<h4><font color="#008000">Acknowlegement:</font></h4>
The development of this library is supported by EU within the project, Clean Sky, sub-project, MoMoLib, No. 296369.
The first delivery of this Wavelet library is made in October 2013.


</p>
<br>
<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.Examples" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples"
>Examples</A>
</TD><TD>Some examples to use this Wavelet Library</TD></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.MRA" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.MRA"
>MRA</A>
</TD><TD>Application: One-dimensional multi-resolution analysis</TD></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.Denoising" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Denoising"
>Denoising</A>
</TD><TD>Application: One dimensional signal denoising</TD></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.Transform" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform"
>Transform</A>
</TD><TD>Functions for wavelet transform</TD></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.Families" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families"
>Families</A>
</TD><TD>Functions about wavelet families</TD></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.General" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General"
>General</A>
</TD><TD>General functions</TD></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.Records" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Records"
>Records</A>
</TD><TD>Records, mainly used for graphic user interface</TD></TR>
<TR><TD><IMG SRC="Wavelet.ExamplesS.png" ALT="Wavelet.Types" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Types"
>Types</A>
</TD><TD>Definitions of enumeration values</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Examples<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.Examples</H2>
<B>Some examples to use this Wavelet Library</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This section provides several examples. They serve as a starting point for the users to start their work with this library. 
Most examples can be accessed through a graphic interface for setting input parameters and displaying results.
</p><p>
To execute the examples that read simulation result data from MAT files, the two Modelica models (testSigna1 and testSignal2) 
have to be firstly run in Dymola, so that the MAT files are generated and stored in the hard disk.
</p>
<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.Examples.displayWaveletS.png" ALT="Wavelet.Examples.displayWavelet" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.displayWavelet"
>displayWavelet</A>
</TD><TD>Display the wavelet available in this Wavelet Library</TD></TR>
<TR><TD><IMG SRC="Wavelet.Examples.displayWaveletS.png" ALT="Wavelet.Examples.cwtChirpCurve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.cwtChirpCurve"
>cwtChirpCurve</A>
</TD><TD>CWT of a chirp signal with outputs shown in curves</TD></TR>
<TR><TD><IMG SRC="Wavelet.Examples.displayWaveletS.png" ALT="Wavelet.Examples.cwtChirpImage" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.cwtChirpImage"
>cwtChirpImage</A>
</TD><TD>CWT of a chirp signal with outputs shown with curves and images</TD></TR>
<TR><TD><IMG SRC="Wavelet.Examples.displayWaveletS.png" ALT="Wavelet.Examples.fileData_cwtn" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.fileData_cwtn"
>fileData_cwtn</A>
</TD><TD>CWT of the simulation result read from a MAT file</TD></TR>
<TR><TD><IMG SRC="Wavelet.Examples.displayWaveletS.png" ALT="Wavelet.Examples.fileDataMRA" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.fileDataMRA"
>fileDataMRA</A>
</TD><TD>MRA of the simulation result read from a MAT file</TD></TR>
<TR><TD><IMG SRC="Wavelet.Examples.displayWaveletS.png" ALT="Wavelet.Examples.fileDataDenoising" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.fileDataDenoising"
>fileDataDenoising</A>
</TD><TD>Denoising of the simulation result read from a MAT file</TD></TR>
<TR><TD><IMG SRC="Wavelet.Examples.testSignal1S.png" ALT="Wavelet.Examples.testSignal1" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.testSignal1"
>testSignal1</A>
</TD><TD>Generates a test signal for analysis</TD></TR>
<TR><TD><IMG SRC="Wavelet.Examples.testSignal1S.png" ALT="Wavelet.Examples.testSignal2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Examples.testSignal2"
>testSignal2</A>
</TD><TD>Generates a test signal for analysis</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE displayWavelet<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.displayWavelet"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.displayWavelet</H2>
<B>Display the wavelet available in this Wavelet Library</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This example displays the wavelet and scaling functions of a wavelet family in one diagram. For a wavelet that has no scaling function,
only the wavelet function is displayed. For the complex wavelets, the real and imaginary parts are displayed with two curves.
The user is able to select a wavelet by its name and set its parameters through a graphic interface. 
</p><p>
Please refer to the description of
<A HREF="#Wavelet.Families"
>wavelet families</a> for the detailed information about the available wavelets
in this library.
</p><p>
Because of the length of discrete Meyer wavelet, the display of it takes a long time.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wp</TD><TD>&nbsp;</TD><TD>Parameters for generating wavelet and scaling functions. See wavFunc() for detailed description of the parameters.</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cwtChirpCurve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.cwtChirpCurve"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.cwtChirpCurve</H2>
<B>CWT of a chirp signal with outputs shown in curves</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out continuous wavelet transform of a chirp signal with graphic user interface. The data to be 
analyzed are given as default input values in the function. 
Bothe the original data and the transform result are shown with curves. 
</p><p>
Since simple default values are provided with this function, a direct execution of this 
function without any extra input parameters will deliver a complete MRA analysis for an example.
</p><p>
Refer to the description of <A HREF="#Wavelet.Families"
>Families</a> for detailed 
information about the available wavelets.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>signal[:]</TD><TD>{1.0000,1.0000,0.9999,0.9996...</TD><TD>Vector, the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>scales[:]</TD><TD>{2,8,32}</TD><TD>Scales</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wIn</TD><TD>&nbsp;</TD><TD>Input parameters for wavelet filters and functions</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cwtChirpImage<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.cwtChirpImage"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.cwtChirpImage</H2>
<B>CWT of a chirp signal with outputs shown with curves and images</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out continuous wavelet transform of a chirp signal with graphic user interface. The data to be 
analyzed are given as default input values in the function. 
The original data are shown with a curve. The transform result will be shown in an image with pseudo-color. 
For showing this image, the 'Plot3D' library has to be available.
</p><p>
Since simple default values are provided with this function, a direct execution of this 
function without any extra input parameters will deliver a complete MRA analysis for an example.
</p><p>
Refer to the description of <A HREF="#Wavelet.Families"
>Families</a> for detailed 
information about the available wavelets.
</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>signal[:]</TD><TD>{1.0000,1.0000,0.9999,0.9996...</TD><TD>Vector, the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>scales[:]</TD><TD>{i for i in 1:16}</TD><TD>Scales</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wIn</TD><TD>&nbsp;</TD><TD>Input parameters for wavelet filters and functions</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fileData_cwtn<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.fileData_cwtn"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.fileData_cwtn</H2>
<B>CWT of the simulation result read from a MAT file</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out continuous wavelet transform with graphic user interface. The data to be 
analyzed are to be read from the *.MAT data file that is generated by Dymola. 
The original data are shown in a curve. The transform result is shown in an image with pseudo-color. 
For showing this image, the 'Plot3D' library has to be available.
</p><p>
Since simple default values are provided with this function, a direct execution of this 
function without any extra input parameters will deliver a complete MRA analysis for an example.
Due to large computational amount, this example will take some time (usually below 30 seconds)
to show the transform results.
</p><p>
Refer to the description of <A HREF="#Wavelet.Families"
>Families</a> for detailed 
information about the available wavelets.
</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input data</TD></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;testSignal2.mat&quot;</TD><TD>The MAT file containing the signal to be analyzed</TD></TR>
<TR><TD>String</TD><TD>signalName</TD><TD>&quot;y&quot;</TD><TD>The signal name to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>t0</TD><TD>0.0</TD><TD>Start time of the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>t1</TD><TD>1.0</TD><TD>End time of the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>fs</TD><TD>500.0</TD><TD>Sampling frequency of the signal for analysis. 
    This is used to generate an equidistant time grid with the expected time step. 
    If fs == 0, the simulation time grid will be used, even if it is none-equidistant.
    Since wavelet analysis has to be done in equidistant time grid, non-equidistant time grids
    usually cause incorrect results.</TD></TR>
<TR><TD>Real</TD><TD>scales[:]</TD><TD>{i for i in 1:4:64}</TD><TD>Scales</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wIn</TD><TD>&nbsp;</TD><TD>Input parameters for wavelet filters and functions</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fileDataMRA<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.fileDataMRA"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.fileDataMRA</H2>
<B>MRA of the simulation result read from a MAT file</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out the complete wavelet MRA with graphic user interface. The data to be 
analyzed are to be read from the *.MAT data file that is generated by Dymola. Please note that 
only the wavelets of types 1, 2 and 3 are possible for MRA. 
Otherwise running errors will occur. The results are displayed with multiple curves. 
It is possible to show either the wavelet coefficients at different 
levels or the signals that are reconstructed with the coefficients of different single levels. 
</p><p>
Since simple default values are provided with this function, a direct execution of this 
function without any extra input parameters will deliver a complete MRA analysis for an example.
</p><p>
Refer to the description of <A HREF="#Wavelet.Families"
>Families</a> for detailed 
information about the available wavelets.

</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input data</TD></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;testSignal2.mat&quot;</TD><TD>The MAT file containing the signal to be analyzed</TD></TR>
<TR><TD>String</TD><TD>signalName</TD><TD>&quot;y&quot;</TD><TD>The signal name to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>t0</TD><TD>0.0</TD><TD>Start time of the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>t1</TD><TD>1.0</TD><TD>End time of the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>fs</TD><TD>200.0</TD><TD>Sampling frequency of the signal for analysis. 
    This is used to generate an equidistant time grid with the expected time step. 
    If fs == 0, the simulation time grid will be used, even if it is none-equidistant.
    Since wavelet analysis has to be done in equidistant time grid, non-equidistant time grids
    usually cause incorrect results.</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wd</TD><TD>&nbsp;</TD><TD>Wavelet definition. Note: Only (bi)orthogonal wavelets can be used for MRA. Valid parameters are wavID (&lt;=7), Nd, Nr and range (dMeyer)</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.mraParameters"
>mraParameters</A></TD><TD>mp</TD><TD>&nbsp;</TD><TD>Parameters for MRA</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fileDataDenoising<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.fileDataDenoising"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.fileDataDenoising</H2>
<B>Denoising of the simulation result read from a MAT file</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out denoising operation to the one-dimensional data read from a specified *.MAT file, which is a simulation database 
generated by Dymola. 
The original data, the decomposed data in 
different levels, the denoised data in all levels and the denoised data are displayed with diagrams. 
In addition, the noise that is removed from the signal is displayed in a diagram, too.
</p><p>
The default input values provide an example to show the functionality of this function. 
</p><p>
Refer to the description of <A HREF="#Wavelet.Families"
>Families</a> for detailed 
information about the available wavelets.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input data</TD></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;testSignal2.mat&quot;</TD><TD>The MAT file containing the signal to be analyzed</TD></TR>
<TR><TD>String</TD><TD>signalName</TD><TD>&quot;y&quot;</TD><TD>The signal name to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>t0</TD><TD>0.0</TD><TD>Start time of the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>t1</TD><TD>1.0</TD><TD>End time of the signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>fs</TD><TD>200.0</TD><TD>Sampling frequency of the signal for analysis. 
    This is used to generate an equidistant time grid with the expected time step. 
    If fs == 0, the simulation time grid will be used, even if it is none-equidistant.
    Since wavelet analysis has to be done in equidistant time grid, non-equidistant time grids
    usually cause incorrect results.</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wd</TD><TD>&nbsp;</TD><TD>Wavelet definition. Note: Only (bi)orthogonal wavelets can be used for MRA. Valid parameters are wavID (&lt;=7), Nd, Nr and range (dMeyer)</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.denoisParameters"
>denoisParameters</A></TD><TD>dp</TD><TD>&nbsp;</TD><TD>Data and parameters for wavelet denoising</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>Denoised signal</TD></TR>
<TR><TD>Real</TD><TD>noise[:]</TD><TD>Noise removed from signal</TD></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>Original wavelet coefficients of all levels, details see wavDec()</TD></TR>
<TR><TD>Real</TD><TD>cth[:]</TD><TD>Wavelet coefficients of all levels after applying thresholds</TD></TR>
<TR><TD>Integer</TD><TD>len[:]</TD><TD>Lengths of coefficients for each levels, details see wavDec()</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE testSignal1<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.testSignal1"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.testSignal1</H2>
<B>Generates a test signal for analysis</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This simple model generates a sum of three sinusoidal signals with different frequencies and magnitudes. 
</p><p>
After running this model in Dymola, all simulation data are saved in testSignal1.MAT file in the hard disk. 
</p>
<pre></PRE><P>
Extends from Modelica.Blocks.Interfaces.SignalSource (Base class for continuous signal source).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>offset</TD><TD>0</TD><TD>Offset of output signal y</TD></TR>
<TR><TD>Time</TD><TD>startTime</TD><TD>0</TD><TD>Output y = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<P><H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>output RealOutput</TD><TD>y</TD><TD>Connector of Real output signal</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE testSignal2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Examples.testSignal2"></A><A HREF="#Wavelet.Examples"
>Wavelet.Examples</A>.testSignal2</H2>
<B>Generates a test signal for analysis</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This simple model generates a sum of sinusoidal signals with different frequencies and magnitudes. 
</p><p>
After running this model in Dymola, all simulation data are saved in testSignal2.MAT file in the hard disk. 
</p>
<pre></PRE><P>
Extends from Modelica.Blocks.Interfaces.SignalSource (Base class for continuous signal source).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>offset</TD><TD>0</TD><TD>Offset of output signal y</TD></TR>
<TR><TD>Time</TD><TD>startTime</TD><TD>0</TD><TD>Output y = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<P><H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>output RealOutput</TD><TD>y</TD><TD>Connector of Real output signal</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE MRA<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.MRA"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.MRA</H2>
<B>Application: One-dimensional multi-resolution analysis</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
The one dimensional wavelet Multi-Resolution-Analysis (MRA) toolbox is an application function group created on the wavelet 
transform base library. 
Wavelet MRA carries out an N-level wavelet decomposition to obtain the wavelet coefficients in N detail levels and one
approximation level. The coefficients of every single level are then used to reconstruct the signal separately. 
The result is a series of signals, each of which represents a certain frequency range of the original signal. In this way,
the original signal can be observed in different (N+1) resolutions.
</p><p>
This toolbox provides two main functions for MRA. Function <A HREF="#Wavelet.MRA.mra"
>mra</a> carries out 
numerical calculation and outputs MRA results in a matrix. Function <A HREF="#Wavelet.MRA.mraGUI"
>mraGUI</a> 
provides a graphic user interface to directly display the analysis results. It provides a further possibility to show
the wavelet coefficients in every singles levels.
</p><p>
Only orthogonal, biorthogonal and discrete Meyer wavelets are possible for MRA. Please refer to the description of
<A HREF="#Wavelet.Families"
>wavelet families</a> for the detailed information about the available wavelets
in this library.
</p>
<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.MRA.mraGUI" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.MRA.mraGUI"
>mraGUI</A>
</TD><TD>Graphic user interface for multi-resolution analysis (MRA)</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.MRA.mra" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.MRA.mra"
>mra</A>
</TD><TD>Wavelet multi-resolution analysis (MRA)Graphic user interface for multi-resolution analysis (MRA)</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.MRA.tuneCoef" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.MRA.tuneCoef"
>tuneCoef</A>
</TD><TD>Tune the wavelet coefficients of all decomposition levels</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE mraGUI<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.MRA.mraGUI"></A><A HREF="#Wavelet.MRA"
>Wavelet.MRA</A>.mraGUI</H2>
<B>Graphic user interface for multi-resolution analysis (MRA)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out the complete wavelet MRA with graphic user interface. Please note that 
only the wavelets of types 1, 2 and 3 are possible for MRA. 
Otherwise running errors will occur. The results are displayed with multiple curves. 
It is possible to show either the wavelet coefficients at different 
levels or the signals that are reconstructed with the coefficients of different single levels. 
</p><p>
Since simple default values are provided with this function, a direct execution of this 
function without any extra input parameters will deliver a complete MRA analysis for an example.
</p><p>
Refer to the description of <A HREF="#Wavelet.Families"
>Families</a> for detailed 
information about the available wavelets.

</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input data</TD></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{0.9594,3.6278,7.6766,8.3415...</TD><TD>Signal to be analyzed</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wd</TD><TD>&nbsp;</TD><TD>Wavelet definition. Note: Only (bi)orthogonal wavelets can be used for MRA. Valid parameters are wavID (&lt;=7), Nd, Nr and range (dMeyer)</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.mraParameters"
>mraParameters</A></TD><TD>mp</TD><TD>&nbsp;</TD><TD>Parameters for MRA</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE mra<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.MRA.mra"></A><A HREF="#Wavelet.MRA"
>Wavelet.MRA</A>.mra</H2>
<B>Wavelet multi-resolution analysis (MRA)Graphic user interface for multi-resolution analysis (MRA)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out the complete wavelet MRA and outputs decomposed signals in all levels after coefficient tuning. 
Please note that only the wavelets of types 1 (orthogonal), 2 (bi-orthogonal) and 3 (discrete Meyer) are possible for MRA. 
Otherwise running errors will occur. 
</p><p>
Since default values are provided with this function, a direct execution of this function without extra input parameters 
will deliver a simple example.
</p><p>
Refer to the description of <A HREF="#Wavelet.Families"
>Families</a> for detailed information about the available wavelets.

</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input data</TD></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{0.9594,3.6278,7.6766,8.3415...</TD><TD>Signal to be analyzed</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wd</TD><TD>&nbsp;</TD><TD>Wavelet definition. Note: Only (bi)orthogonal wavelets can be used for MRA. Valid parameters are wavID (&lt;=7), Nd, Nr and range (dMeyer)</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.mraParameters"
>mraParameters</A></TD><TD>mp</TD><TD>&nbsp;</TD><TD>Parameters for MRA</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:, :]</TD><TD>Reconstructed signals with tuned coefficients in all levels. y[1,:] -- reconstructed signal, y[2,:] -- 1st detail level, 
    y[3,:] -- 2nd detail level, ..., y[N+1,:] -- N-th detail level, y[N+2,:] -- approximation level, where N is the number of 
    the decomposition levels.</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE tuneCoef<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.MRA.tuneCoef"></A><A HREF="#Wavelet.MRA"
>Wavelet.MRA</A>.tuneCoef</H2>
<B>Tune the wavelet coefficients of all decomposition levels</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function supports wavelet MRA. After wavelet (multi-level) decomposition, the coefficients are usually tuned in order to change the signal magnitude at different levels.
This function is able to freely change the magnitude of the coefficients at each level by multiplying them with a given factor, which could be any real value. 
</p><p>
The definition of c[:] and len[:] are the same as in the function <A HREF="#Wavelet.Transform.wavDec"
>wavDec()</a>.
</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c0[:]</TD><TD>{-0.707,-0.707,-0.707,-0.706...</TD><TD>Original wavelet coefficients of all levels</TD></TR>
<TR><TD>Integer</TD><TD>len[:]</TD><TD>{13,7,4,2,2}</TD><TD>Lengths of wavelet coefficients for each levels</TD></TR>
<TR><TD>Real</TD><TD>ratio[:]</TD><TD>{1,0.1,2,-1}</TD><TD>{rD1, rD2, ..., rDN, rAN}, tuning factors of all levels. </TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c1[size(c0, 1)]</TD><TD>Tuned wavelet coefficients of all levels</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Denoising<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Denoising"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.Denoising</H2>
<B>Application: One dimensional signal denoising</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
The wavelet denoising toolbox is an application function group created on the wavelet transform base library. 
Wavelet denoising is based on the consideration that the noise energy in the data is significantly lower than the 
signal energy, or the part of the data that contains useful information. In this case, the noise is mainly represented 
with the wavelet coefficients that have small magnitudes. If these coefficients are removed (set to be zeros) and the signal 
 is reconstructed, the noise will be eliminated from the original data. Therefore, wavelet denoising is only suitable for 
the cases where the signal-to-noise ratio is high.
</p><p>
The thresholds to decide which coefficients are to be removed are usually empirically determined based on the data to 
be analyzed. However, there are methods (the function <A HREF="#Wavelet.Denoising.thSelect"
>thSelect</a>) to automatically select the thresholds by analyzing the input data if the noise 
has normal distribution property. It has to be noted that the thresholds calculated by thSelect in this toolbox 
are valid only if the noise has <b>normal (Gaussian) distribution</b> with <b>zero mean </b> and <b>standard deviation of one</b>!
Otherwise, the data have to be pre-conditioned or the thresholds have to be manually selected by the user. 
</p><p>
The same data processing for denoising could also be used for data compression. The idea is based on such consideration: 
The wavelet coefficients with small magnitudes contain little information about the original signal. By removing these 
coefficients, the data amount can be greatly reduced while not much information is lost. If a suitable wavelet is used,
most coefficients might have very small magnitudes. Thus, a large compression ratio can be achieved.
</p><p>
Only orthogonal, biorthogonal or discrete Meyer wavelets can be used for wavelet denoising.
</p>
<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Denoising.denoisGUI" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Denoising.denoisGUI"
>denoisGUI</A>
</TD><TD>Graphic user interface for 1D wavelet denoising</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Denoising.denois" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Denoising.denois"
>denois</A>
</TD><TD>1D wavelet denoising</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Denoising.thSelect" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Denoising.thSelect"
>thSelect</A>
</TD><TD>Calculates threshold value for denoising</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Denoising.thApply" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Denoising.thApply"
>thApply</A>
</TD><TD>Apply soft or hard thresholding</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE denoisGUI<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Denoising.denoisGUI"></A><A HREF="#Wavelet.Denoising"
>Wavelet.Denoising</A>.denoisGUI</H2>
<B>Graphic user interface for 1D wavelet denoising</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function is a modified version of the function <A HREF="#Wavelet.Families"
>denois</a>. 
It provides graphic user interface (GUI) for parameter input and displaying denoising results. 
Instead of filter banks, the wavelet is specified with its name. The original data, the decomposed data in 
different levels, the denoised data in all levels and the denoised data are displayed with diagrams. 
In addition, the noise that is removed from the signal is displayed in a diagram, too.
</p><p>
The default input values provide an example to show the functionality of this function. 
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input data</TD></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{-1.3853,1.5788,2.2041,3.982...</TD><TD>Signal to be analyzed</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wd</TD><TD>&nbsp;</TD><TD>Wavelet definition. Note: Only (bi)orthogonal wavelets can be used for MRA. Valid parameters are wavID (&lt;=7), Nd, Nr and range (dMeyer)</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.denoisParameters"
>denoisParameters</A></TD><TD>dp</TD><TD>&nbsp;</TD><TD>Data and parameters for wavelet denoising</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>Denoised signal</TD></TR>
<TR><TD>Real</TD><TD>noise[:]</TD><TD>Noise removed from signal</TD></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>Original wavelet coefficients of all levels, details see wavDec()</TD></TR>
<TR><TD>Real</TD><TD>cth[:]</TD><TD>Wavelet coefficients of all levels after applying thresholds</TD></TR>
<TR><TD>Integer</TD><TD>len[:]</TD><TD>Lengths of coefficients for each levels, details see wavDec()</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE denois<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Denoising.denois"></A><A HREF="#Wavelet.Denoising"
>Wavelet.Denoising</A>.denois</H2>
<B>1D wavelet denoising</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out the wavelet denoising calculation for a data. The wavelet filter bank must be available for calling
this function. This has to be obtained by wavelet filter functions.
</p><p>
It has to be noted that the thresholds calculated by thSelect in this toolbox 
are valid only if the noise has <b>normal (Gaussian) distribution</b> with <b>zero mean </b> and <b>standard deviation of one</b>!
Otherwise, the data have to be pre-conditioned or the thresholds have to be manually selected by the user. 
</p><p>
The manual selection of the thresholds has the possibility that the thresholds for the levels can be different. The thresholds
are given in the input parameter, th[:], each element of which is used for one level. If a threshold for a level is less than
zero, the default threshold automatically calculated by <A HREF="#Wavelet.Denoising.thSelect"
>thSelect</a> will be used.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{-1.3853,1.5788,2.2041,3.982...</TD><TD>Data to be denoised</TD></TR>
<TR><TD>Integer</TD><TD>decLevel</TD><TD>2</TD><TD>Wavelet decomposition levels</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>{0.7071067811865476,0.707106...</TD><TD>Wavelet low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>{-0.7071067811865476,0.70710...</TD><TD>Wavelet high pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>{0.7071067811865476,0.707106...</TD><TD>Wavelet low pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>{0.7071067811865476,-0.70710...</TD><TD>Wavelet high pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>th[:]</TD><TD>{-1,-1}</TD><TD>Thresholds for all decomposition levels with th[1] for the first detail level (highest frequency components)</TD></TR>
<TR><TD>Boolean</TD><TD>sorh</TD><TD>true</TD><TD>Soft (false) or hard (true) thresholding for all decomposition levels</TD></TR>
<TR><TD><A HREF="#Wavelet.Types.threshMethod"
>threshMethod</A></TD><TD>thMethod</TD><TD>1</TD><TD>Method for automatic threshold calculation</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>Denoised data</TD></TR>
<TR><TD>Real</TD><TD>noise[:]</TD><TD>Noise removed from the data, = u-y</TD></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>Wavelet coefficients before denoising</TD></TR>
<TR><TD>Real</TD><TD>cth[:]</TD><TD>Wavelet coefficients after denoising</TD></TR>
<TR><TD>Integer</TD><TD>len[:]</TD><TD>Length of wavelet coefficients of all levels</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE thSelect<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Denoising.thSelect"></A><A HREF="#Wavelet.Denoising"
>Wavelet.Denoising</A>.thSelect</H2>
<B>Calculates threshold value for denoising</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function analyzes the input data and calculates a common threshold for wavelet denoising for all detail levels
using the specified methods. Four methods are available:
</p><p>
1. Fixed form: The threshold is calculated as  sqrt(2*log(size(u,1))).
</p><p>
2. SURE: The threshold is calculated based on Stein's Unbiased Risk Estimate (SURE) of risk, which is a quadratic loss function.
</p><p>
3. Heuristic SURE: This is a heuristic version of the SURE method. It is actually a combination of the first two methods. For the signal with strong
noises, the fixed form method is used. Otherwise, SURE method id used.
</p><p>
4. Minimal maximum: The threshold is estimated to realize the minimum of the maximum mean square error of the observed data. This method is derived 
from statistic theory.
</p><p>
It has to be noted that the thresholds calculated by thSelect in this toolbox 
are valid only if the noise has <b>normal (Gaussian) distribution</b> with <b>zero mean </b> and <b>standard deviation of one</b>!
Otherwise, it is recommended that the data are to be pre-conditioned or the thresholds be manually selected.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{-1.3853,1.5788,2.2041,3.982...</TD><TD>Signal vector</TD></TR>
<TR><TD><A HREF="#Wavelet.Types.threshMethod"
>threshMethod</A></TD><TD>thID</TD><TD>1</TD><TD>Threshold calculation method</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>th</TD><TD>Threshold value</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE thApply<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Denoising.thApply"></A><A HREF="#Wavelet.Denoising"
>Wavelet.Denoising</A>.thApply</H2>
<B>Apply soft or hard thresholding</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{0,1,2,3,4,5,6,7,8,9}</TD><TD>Input vector</TD></TR>
<TR><TD>Real</TD><TD>th</TD><TD>5</TD><TD>Threshold value</TD></TR>
<TR><TD>Boolean</TD><TD>sorh</TD><TD>true</TD><TD>Soft (false) or hard (true) thresholding</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>Vector after thresholding</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Transform<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.Transform</H2>
<B>Functions for wavelet transform</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This library includes the following one-dimensional wavelet transforms and inverse transforms:
</p><p>
1. Continuous wavelet transform: cwt() and cwtn();</p><p>
2. Discrete wavelet transform: dwt();</p><p>
3. Inverse discrete wavelet transform: idwt();</p><p>
4. Multi-level wavelet decomposition: wavDec();</p><p>
5. Multi-level wavelet reconstruction: wavRec();</p><p>
6. Single level reconstruction based on multi-level wavelet coefficients: wavRec1();
</p><pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.cwt" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.cwt"
>cwt</A>
</TD><TD>One-dimensional continuous wavelet transform with a given wavelet function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.cwtn" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.cwtn"
>cwtn</A>
</TD><TD>One-dimensional continuous wavelet transform with a given wavelet name</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.dwt" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.dwt"
>dwt</A>
</TD><TD>One-dimensional discrete wavelet transform (one-level decomposition)</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.idwt" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.idwt"
>idwt</A>
</TD><TD>One-dimensional inverse discrete wavelet transform (one-level reconstruction)</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.wavDec" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.wavDec"
>wavDec</A>
</TD><TD>Wavelet multilevel decomposition</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.wavRec" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.wavRec"
>wavRec</A>
</TD><TD>Wavelet multilevel reconstruction</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.wavRec1" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.wavRec1"
>wavRec1</A>
</TD><TD>Wavelet reconstruction using coefficients from a single level</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Transform.wavCoef1" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Transform.wavCoef1"
>wavCoef1</A>
</TD><TD>Extract the wavelet coefficients of a single level</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cwt<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.cwt"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.cwt</H2>
<B>One-dimensional continuous wavelet transform with a given wavelet function</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
One-dimensional CWT transforms a vector to a two dimensional image. The first dimension (horizontal axis) 
is the same as the original data. The second dimension (vertical axis) is the scale, 
similar to frequency. The scales are defined by the input parameter, scales. Larger scale values correspond to lower frequencies.
</p><p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example with a simple saw-tooth signal.</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1.0000,1.0000,0.9999,0.9996...</TD><TD>Signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>scales[:]</TD><TD>{1,4,16}</TD><TD>Scales to be transformed</TD></TR>
<TR><TD>Real</TD><TD>w[:]</TD><TD>{1,-1}</TD><TD>Wavelet function for the transform</TD></TR>
<TR><TD>Real</TD><TD>x_w[:]</TD><TD>{0,1}</TD><TD>Regular grid of the wavelet function</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>coefs[size(scales, 1), size(u, 1)]</TD><TD>A two dimensional matrix of wavelet coefficients. 
  Each column corresponds to one element of the input parameter, scales.</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cwtn<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.cwtn"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.cwtn</H2>
<B>One-dimensional continuous wavelet transform with a given wavelet name</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out one-dimensional CWT transform, same as the function, cwt(). 
The only difference is that cwtn() receives the wavelet name as input. 
</p><p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example with a simple saw-tooth signal.</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input data</TD></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1.0000,1.0000,0.9999,0.9996...</TD><TD>Signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>scales[:]</TD><TD>{1,4,16}</TD><TD>Scales for the transformation</TD></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wIn</TD><TD>&nbsp;</TD><TD>Wavelet definition</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>coefs[size(scales, 1), size(u, 1)]</TD><TD>A two dimensional matrix of wavelet coefficients. 
  Each column corresponds to one element of the input parameter, scales.</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dwt<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.dwt"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.dwt</H2>
<B>One-dimensional discrete wavelet transform (one-level decomposition)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function calculates discrete wavelet transform (one-level wavelet decomposition) of the input signal, u. 
Before transformation, the original signal is extended at both ends with zero padding. 
The length of the two result vectors is floor((size(u,1)+size(lod,1)-1)/2).
</p><p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example with a simple saw-tooth signal.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1,2,1,2,1,2,3,4,1}</TD><TD>Signal to be analyzed</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>{0.707,0.707}</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[size(lod, 1)]</TD><TD>{-0.707,0.707}</TD><TD>High pass filter for decomposition</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>ca[:]</TD><TD>Approximation coefficients, size(ca,1) = ceil(size(u,1)/2)</TD></TR>
<TR><TD>Real</TD><TD>cd[size(ca, 1)]</TD><TD>Detail coefficients</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE idwt<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.idwt"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.idwt</H2>
<B>One-dimensional inverse discrete wavelet transform (one-level reconstruction)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function calculates inverse discrete wavelet transform (one-level wavelet reconstruction) using the input approximation 
and detail wavelet coefficients, ca and cd. 
The coefficient vectors are extended at both ends with zero padding before calculation. 
The length of the reconstructed data is usually (but not always) equal to the length of the original signal if the length is not specified.
</p><p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example to generate a simple saw-tooth signal.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>ca[:]</TD><TD>{2.121,2.121,2.121,4.95,0.707}</TD><TD>Approximation coefficients</TD></TR>
<TR><TD>Real</TD><TD>cd[size(ca, 1)]</TD><TD>{-0.707,-0.707,-0.707,-0.707...</TD><TD>Detail coefficients</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>{0.707,0.707}</TD><TD>Low pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[size(lor, 1)]</TD><TD>{0.707,-0.707}</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Integer</TD><TD>ny</TD><TD>0</TD><TD>Length of the result, y (the central part will be extracted). If ny == 0, size(y,1) = 2*size(ca,1) - size(lor,1) +2</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>Reconstructed signal</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavDec<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.wavDec"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.wavDec</H2>
<B>Wavelet multilevel decomposition</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out multi-level wavelet decomposition. </p><p>
Parameter, len, is a vector with (N+2) elements, where N is the number of levels. 
It contents the length information of the coefficients in all levels. 
len[1] is the length of the original signal vector; 
len[2] is the length of the detail coefficient vector of the first decomposition level; 
len[3] is the length of the detail coefficient vector of the second decomposition level; and so forth.
Finally, len[N+2] contains the length of the approximation coefficient vector.
Parameter, c, contains the wavelet coefficients of all levels, firstly the first detail level, 
then the second detail level and so on, and finally the approximation coefficients.
This is described again in detail as follows:
</p>
<h4><font color="#008000">Definition of the outputs</font></h4>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td><b>Data</b></td>      <td><b>Length</b></td>      <td><b>Location</b></td>      </tr>
        
  <tr><td>Original signal</td>                    <td>len[1]</td>   <td>u</td></tr>
  <tr><td>First level detail coefficients</td>   <td>len[2]</td>   <td>c[1 : len[2]]</td></tr>
  <tr><td>Second level detail coefficients</td>   <td>len[3]</td>   <td>c[len[2]+1 : len[2]+len[3]]</td></tr>
  <tr><td>...</td>                                <td>...</td>       <td>...</td></tr>
  <tr><td>k-th level detail coefficients</td>   <td>len[k+1]</td>   <td>c[sum(len[2:k])+1 : sum(len[2:k+1])]</td></tr>
  <tr><td>...</td>                              <td>...</td>        <td>...</td></tr>
  <tr><td>N-th level detail coefficients</td>   <td>len[N+1]</td>   <td>c[sum(len[2:N])+1 : sum(len[2:N+1])]</td></tr>
  <tr><td>Approximation coefficients</td>        <td>len[N+2]</td>   <td>c[sum(len[2:N+1])+1 : sum(len[2:N+2])]</td></tr>

</table>
<p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example with a simple saw-tooth signal.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1,2,1,2,1,2,3,4,1,2,3,4,1}</TD><TD>Signal to be analyzed</TD></TR>
<TR><TD>Integer</TD><TD>N</TD><TD>3</TD><TD>Decomposition level</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>{0.707,0.707}</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[size(lod, 1)]</TD><TD>{-0.707,0.707}</TD><TD>High pass filter for decomposition</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>Detail and approximation coefficients. For data structure see the information section</TD></TR>
<TR><TD>Integer</TD><TD>len[N + 2]</TD><TD>Lengths of the coefficient vectors of all levels. For data structure see the information section</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavRec<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.wavRec"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.wavRec</H2>
<B>Wavelet multilevel reconstruction</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function transforms the wavelet coefficients, which are obtained with multi-level wavelet decomposition, back to 
the original signal. The definitions of the input parameters, c and len, are same as the function <A HREF="#Wavelet.Transform.wavDec"
>wavDec()</a>.
</p><p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example to generate a simple saw-tooth signal.
</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>{-0.707,-0.707,-0.707,-0.706...</TD><TD>Detail and approximation coefficients. For data structure see the information section</TD></TR>
<TR><TD>Integer</TD><TD>len[:]</TD><TD>{13,7,4,2,2}</TD><TD>Coefficient vector lengths of all levels. For data structure see the information section</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>{0.707,0.707}</TD><TD>Low pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[size(lor, 1)]</TD><TD>{0.707,-0.707}</TD><TD>High pass filter for reconstruction</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>Reconstructed signal</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavRec1<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.wavRec1"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.wavRec1</H2>
<B>Wavelet reconstruction using coefficients from a single level</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function carries out a modified wavelet reconstruction: 
It reconstructs the signal with the wavelet coefficients from only one single level. 
All other coefficients are set zero.
This operation is useful for some wavelet analysis, e.g. multi-resolution analysis and wavelet de-noising.
</p><p>
The definitions of input parameters, c and len, are same as the function <A HREF="#Wavelet.Transform.wavDec"
>wavDec()</a>.
</p><p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example.
</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>{-0.707,-0.707,-0.707,-0.706...</TD><TD>Wavelet coefficients of all levels</TD></TR>
<TR><TD>Integer</TD><TD>len[:]</TD><TD>{13,7,4,2,2}</TD><TD>Lengths of coefficients of all levels</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>{0.707,0.707}</TD><TD>Low pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[size(lor, 1)]</TD><TD>{0.707,-0.707}</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Integer</TD><TD>level</TD><TD>2</TD><TD>The level to be reconstructed. 1..N are for the detail levels, 
    where N is the maximum decomposition level. 1 stands for the most detail level (highest frequency).
     N+1 is for the approximation level.</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>Reconstructed signal</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavCoef1<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Transform.wavCoef1"></A><A HREF="#Wavelet.Transform"
>Wavelet.Transform</A>.wavCoef1</H2>
<B>Extract the wavelet coefficients of a single level</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function extracts the coefficients of a specified decomposition level from the data structure of the wavelet coefficients. 
This operation is useful if only the coefficients of a specific level are interested.
</p><p>
The definitions of the input parameters, c and len, are same as the function <A HREF="#Wavelet.Transform.wavDec"
>wavDec()</a>.
</p><p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for the detailed information about the available wavelets.
</p><p>
The default input values provide a quick example.
</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>{-0.707,-0.707,-0.707,-0.706...</TD><TD>Wavelet coefficients of all levels</TD></TR>
<TR><TD>Integer</TD><TD>len[:]</TD><TD>{13,7,4,2,2}</TD><TD>Lengths of coefficient vectors for all levels</TD></TR>
<TR><TD>Integer</TD><TD>level</TD><TD>2</TD><TD>The level to be reconstructed. 1..N are for the detail levels, 
    where N is the maximum decomposition level. 1 stands for the most detail level (highest frequency).
     N+1 is for the approximation level.</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c1[:]</TD><TD>Extracted coefficients</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Families<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.Families</H2>
<B>Functions about wavelet families</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This section defines all available wavelets in this library. Since different wavelets have different properties, 
the functions for different wavelets require different input parameters and generate different output data. 
All available wavelets in this library with the parameters are listed in the following table.
</p><p>Parameter, Nd, specifies the wavelet order. Nr is only used for biorthogonal wavelets, where Nd is for 
decomposition and Nr for reconstruction. 
</p><p>For the wavelets with theoretically unlimited support, e.g. Meyer, Gaussian, etc., the function range 
is set as effective support, [-es, es], if 'range' is not specified (==0). 
</p><p>Parameters, fb and fc, are used for some complex wavelets. These are the so-called frequency parameters 
defining the oscillation properties of the wavelets.
</p><p>'phi' stands for scaling function, and 'psi' for wavelet function. A biorthogonal wavelet has two
scaling and wavelet functions. The first function set is for forward transformation (decomposition); 
the second set is for inverse transformation (reconstruction).
</p><p>Symbol, O, means the corresponding parameter is applicable, - not applicable, for a specific wavelet. 
</p><p>
For generating Meyer wavelets, an external C-function saved in fft_c.c file has to be called. This C-file has to 
be available in the current working directory or the searching path of Modelica must include the directory of fft_c.c file.</p>
<h4><font color="#008000">Applicable parameters of the wavelet families</font></h4>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>Wavelet</b></td>
      <td><b>wavID</b></td>
      <td><b>wavType</b></td>
      <td><b>Nd</b></td>
      <td><b>Nr</b></td>
      <td><b>es</b></td>
      <td><b>range</b></td>
      <td><b>fb</b></td>
      <td><b>fc</b></td>
      <td><b>phi1</b></td>
      <td><b>psi1</b></td>
      <td><b>phi2</b></td>
      <td><b>psi2</b></td>
      </tr>
      
  
  <tr><td>Haar </td>
      <td>1</td> <td>1</td> <td>-</td> <td>-</td> <td>-</td> <td>-</td>  <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Daubechies </td>
      <td>2</td>  <td>1</td> <td>1..20</td> <td>-</td> <td>-</td> <td>-</td>  <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Symlets </td>
      <td>3</td> <td>1</td> <td>1..20</td> <td>-</td> <td>-</td> <td>-</td> <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Coiflets </td>
      <td>4</td> <td>1</td> <td>1..5</td> <td>-</td> <td>-</td> <td>-</td>  <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Biorthogonal spline </td>
      <td>5</td> <td>2</td> <td>1..6</td> <td>1..9</td> <td>-</td> <td>-</td>  <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td>
      </tr>
  
  <tr><td>Reverse biorthogonal spline </td>
      <td>6</td> <td>2</td> <td>1..9</td> <td>1..6</td> <td>-</td> <td>-</td>  <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> 
      </tr>
  
  <tr><td>Discrete Meyer </td>
      <td>7</td> <td>3</td> <td>-</td><td>-</td> <td>8</td> <td>>=0</td>  <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Meyer </td>
      <td>8</td> <td>3</td> <td>-</td> <td>-</td> <td>8</td> <td>>=0</td>  <td>-</td> <td>-</td> <td>O</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Gaussian </td>
      <td>9</td> <td>4</td> <td>1..8</td> <td>-</td><td>5</td> <td>>=0</td>  <td>-</td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Mexican hat </td>
      <td>10</td> <td>4</td> <td>-</td> <td>-</td><td>5</td> <td>>=0</td>  <td>-</td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Morlet </td>
      <td>11</td> <td>4</td> <td>-</td> <td>-</td><td>4</td> <td>>=0</td>  <td>-</td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Complex Gaussian </td>
      <td>12</td> <td>5</td> <td>1..8</td><td>-</td><td>5</td> <td>>=0</td>  <td>-</td> <td>-</td> <td>-</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Complex Morlet </td>
      <td>13</td> <td>5</td> <td>-</td> <td>-</td><td>4</td> <td>>=0</td>  <td>>0</td> <td>>0</td> <td>-</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Complex Shannon </td>
      <td>14</td> <td>5</td> <td>-</td> <td>-</td><td>20</td> <td>>=0</td>  <td>>0</td> <td>>0</td> <td>-</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
  <tr><td>Complex frequency B-spline </td>
      <td>15</td> <td>5</td> <td>1,2,...</td><td>-</td> <td>20</td> <td>>=0</td>  <td>>0</td> <td>>0</td> <td>-</td> <td>O</td> <td>-</td> <td>-</td>
      </tr>
  
</table>

<h4><font color="#008000">Available orders for biorthogonal and reverse biorthogonal wavelets</font></h4>
<p>
For biorthogonal and reverse biorthogonal wavelets, only some combinations of the orders are available. For details, refer to the 
functions, <A HREF="#Wavelet.Families.wavBiorSpline"
>wavBiorSpline</a> and <A HREF="#Wavelet.Families.wavRevBiorSpline"
>wavRevBiorSpline</a>.
</p>

<h4><font color="#008000">Wavelet types</font></h4>
<p>
All wavelets are categorized into five types. They are defined as follows:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>Type</b></td>
      <td><b>Description</b></td>
      </tr>
  
  <tr><td>1</td> <td>Orthogonal wavelets</td> </tr>
  <tr><td>2</td> <td>Biorthogonal wavelets</td> </tr>
  <tr><td>3</td> <td>Non-(bi)orthogonal wavelets with scaling function</td> </tr>
  <tr><td>4</td> <td>Non-(bi)orthogonal wavelets without scaling function</td> </tr>
  <tr><td>5</td> <td>Complex wavelets (without scaling function)</td> </tr>
</table>


<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavFunc" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavFunc"
>wavFunc</A>
</TD><TD>Returns the filter bank and functions of a specific wavelet family</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.scalingWaveFunc" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.scalingWaveFunc"
>scalingWaveFunc</A>
</TD><TD>Generate the scaling and wavelet functions using wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavHaar" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavHaar"
>wavHaar</A>
</TD><TD>Haar wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavDaubechies" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavDaubechies"
>wavDaubechies</A>
</TD><TD>Daubechies wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavSymlets" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavSymlets"
>wavSymlets</A>
</TD><TD>Symlets wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavCoiflets" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavCoiflets"
>wavCoiflets</A>
</TD><TD>Coiflets wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavBiorSpline" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavBiorSpline"
>wavBiorSpline</A>
</TD><TD>Biorthogonal spline wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavRevBiorSpline" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavRevBiorSpline"
>wavRevBiorSpline</A>
</TD><TD>Reverse biorthogonal spline wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavDMeyer" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavDMeyer"
>wavDMeyer</A>
</TD><TD>Discrete Meyer wavelet filters</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavMeyer" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavMeyer"
>wavMeyer</A>
</TD><TD>Meyer wavelet function. The fft_c.c file must be accessible.</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavGaussian" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavGaussian"
>wavGaussian</A>
</TD><TD>Gaussian wavelet function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavMexHat" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavMexHat"
>wavMexHat</A>
</TD><TD>Mexican hat wavelet function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavMorlet" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavMorlet"
>wavMorlet</A>
</TD><TD>Morlet wavelet function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavXGaussian" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavXGaussian"
>wavXGaussian</A>
</TD><TD>Complex Gaussian wavelet function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavXMorlet" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavXMorlet"
>wavXMorlet</A>
</TD><TD>Complex Morlet wavelet function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavXShannon" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavXShannon"
>wavXShannon</A>
</TD><TD>Complex Shannon wavelet function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.Families.wavXFreqBSpline" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Families.wavXFreqBSpline"
>wavXFreqBSpline</A>
</TD><TD>Complex Frequency B-Spline wavelet</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavFunc<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavFunc"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavFunc</H2>
<B>Returns the filter bank and functions of a specific wavelet family</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function provides a common entry to access all available wavelets in this library.
Since different wavelet families require different parameters and return different results,
suitable input parameters must be provided. Not applicable parameters for a specific wavelet
are omitted by the function.
</p><p>
Refer to <A HREF="#Wavelet.Families"
>Wavelet Families</a> 
for detailed information about the available wavelets.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A></TD><TD>wIn</TD><TD>&nbsp;</TD><TD>Input parameters for wavelet filters and functions</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="#Wavelet.Records.wavFuncOut"
>wavFuncOut</A></TD><TD>wOut</TD><TD>Output data of the function wavFunc()</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scalingWaveFunc<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.scalingWaveFunc"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.scalingWaveFunc</H2>
<B>Generate the scaling and wavelet functions using wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
The total length of the functions is (size(lof,1)-1)*2^iteration+1. 
The function support (non-zero part) is (2^iteration -1)*nf-2^iteration+2, shorter than total length. 
One 'zero' is then added at the beginning and multiple 'zeros' are added at the end.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="#Wavelet.Types.wavletID"
>wavletID</A></TD><TD>wavID</TD><TD>1</TD><TD>Id-Number of the wavelet. Necessary only for discrete Meyer wavelet</TD></TR>
<TR><TD>Real</TD><TD>lof[:]</TD><TD>{0.707,0.707}</TD><TD>Wavelet low pass filter</TD></TR>
<TR><TD>Real</TD><TD>hif[:]</TD><TD>{-0.707,0.707}</TD><TD>Wavelet high pass filter</TD></TR>
<TR><TD>Integer</TD><TD>iteration</TD><TD>6</TD><TD>Iteration of the calculations for generating the functions</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[:]</TD><TD>Equidistant grid of the functions</TD></TR>
<TR><TD>Real</TD><TD>phi[:]</TD><TD>The scaling function</TD></TR>
<TR><TD>Real</TD><TD>psi[:]</TD><TD>The wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavHaar<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavHaar"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavHaar</H2>
<B>Haar wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generate the Haar wavelet filter bank. No input parameters are required.
</p>
<pre></PRE><P>

<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:]</TD><TD>Scaling filter</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>High pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>Low pass filter for reconstruction</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavDaubechies<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavDaubechies"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavDaubechies</H2>
<B>Daubechies wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generate the Daubechies wavelet filter banks for the orders up to 10. 
If a wrong order number is given, an empty vector is returned.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>2</TD><TD>Order of the wavelet. order&lt;=10</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:]</TD><TD>Scaling filter</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>High pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>Low pass filter for reconstruction</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavSymlets<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavSymlets"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavSymlets</H2>
<B>Symlets wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generate the Symlets wavelet filter banks for the orders up to 8.
If a wrong order number is given, an empty vector is returned.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>2</TD><TD>Order of the wavelet. order&lt;=8</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:]</TD><TD>Scaling filter</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>High pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>Low pass filter for reconstruction</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavCoiflets<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavCoiflets"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavCoiflets</H2>
<B>Coiflets wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generate the Coiflets wavelet filter banks for the orders up to 5.
If a wrong order number is given, an empty vector is returned.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>2</TD><TD>Order of the wavelet. order&lt;=5</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:]</TD><TD>Scaling filter</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>High pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>Low pass filter for reconstruction</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavBiorSpline<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavBiorSpline"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavBiorSpline</H2>
<B>Biorthogonal spline wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the biorthogonal spline wavelet filters, where Nr is the order of the reconstruction filters, 
and Nd the order of the decomposition filters.
</p>
<p>
Usually, lodFd and hidFr are used for decomposition, and lorFr and hirFd are used for reconstruction.
</p>
<h4><font color="#008000">Available orders of biorthogonal wavelet filters</font></h4>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><i>Nd</i></td>
      <td><i>Nr</i></td>
      </tr>
  
  <tr><td>1, 3, 5</td> <td>1</td>
      </tr>
  
  <tr><td>2, 4, 6, 8 </td> <td>2</td>
      </tr>
  
  <tr><td>1, 3, 5, 7, 9</td> <td>3</td>
      </tr>
  
  <tr><td>4 </td> <td>4</td>
      </tr>
  
  <tr><td>5 </td> <td>5</td>
      </tr>
  
  <tr><td>8 </td> <td>6</td>
      </tr>
  
</table>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>Nd</TD><TD>2</TD><TD>Wavelet order for decomposition</TD></TR>
<TR><TD>Integer</TD><TD>Nr</TD><TD>2</TD><TD>Wavelet order for reconstruction</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Fd[:]</TD><TD>Scaling filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lodFd[:]</TD><TD>High pass filter for decomposition using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>hidFd[:]</TD><TD>Low pass filter for decomposition using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>lorFd[:]</TD><TD>High pass filter for reconstruction using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>hirFd[:]</TD><TD>Low pass filter for reconstruction using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>Fr[:]</TD><TD>Scaling filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>lodFr[:]</TD><TD>High pass filter for decomposition using filter Fr</TD></TR>
<TR><TD>Real</TD><TD>hidFr[:]</TD><TD>Low pass filter for decomposition using filter Fr</TD></TR>
<TR><TD>Real</TD><TD>lorFr[:]</TD><TD>High pass filter for reconstruction using filter Fr</TD></TR>
<TR><TD>Real</TD><TD>hirFr[:]</TD><TD>Low pass filter for reconstruction using filter Fr</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavRevBiorSpline<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavRevBiorSpline"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavRevBiorSpline</H2>
<B>Reverse biorthogonal spline wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the biorthogonal spline wavelet filters, where Nr is the order of the reconstruction filters, 
and Nd the order of the decomposition filters.
</p>
<p>
Usually, lodFd and hidFr are used for decomposition, and lorFr and hirFd are used for reconstruction.
</p>

<h4><font color="#008000">Available orders of biorthogonal wavelet filters</font></h4>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><i>Nd</i></td>
      <td><i>Nr</i></td>
      </tr>
  
  <tr><td>1</td> <td>1, 3, 5</td>
      </tr>
  
  <tr><td>2 </td> <td>2, 4, 6, 8</td>
      </tr>
  
  <tr><td>3 </td> <td>1, 3, 5, 7, 9</td>
      </tr>
  
  <tr><td>4 </td> <td>4</td>
      </tr>
  
  <tr><td>5 </td> <td>5</td>
      </tr>
  
  <tr><td>6 </td> <td>8</td>
      </tr>
  
</table>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>Nd</TD><TD>2</TD><TD>Wavelet order for decomposition</TD></TR>
<TR><TD>Integer</TD><TD>Nr</TD><TD>2</TD><TD>Wavelet order for reconstruction</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Fd[:]</TD><TD>Scaling filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lodFd[:]</TD><TD>High pass filter for decomposition using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>hidFd[:]</TD><TD>Low pass filter for decomposition using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>lorFd[:]</TD><TD>High pass filter for reconstruction using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>hirFd[:]</TD><TD>Low pass filter for reconstruction using filter Fd</TD></TR>
<TR><TD>Real</TD><TD>Fr[:]</TD><TD>Scaling filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>lodFr[:]</TD><TD>High pass filter for decomposition using filter Fr</TD></TR>
<TR><TD>Real</TD><TD>hidFr[:]</TD><TD>Low pass filter for decomposition using filter Fr</TD></TR>
<TR><TD>Real</TD><TD>lorFr[:]</TD><TD>High pass filter for reconstruction using filter Fr</TD></TR>
<TR><TD>Real</TD><TD>hirFr[:]</TD><TD>Low pass filter for reconstruction using filter Fr</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavDMeyer<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavDMeyer"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavDMeyer</H2>
<B>Discrete Meyer wavelet filters</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function returns the filter bank of discrete Meyer wavelet, which is an approximation of continuous Meyer wavelet. 
The filters with the length of 102 points usually provide sufficient accuracy. However, such long filters might cause 
long calculation time. Therefore, this function provides the possibility to return shorter filters. 
The trade-off is lower accuracy. Please note that some lengths will cause significantly large errors. The default length is 22. 
</p>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>22</TD><TD>Filter length (&lt;= 102). The complete length is used if this variable is &lt;= 0</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:]</TD><TD>Scaling filter</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>High pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>Low pass filter for reconstruction</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavMeyer<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavMeyer"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavMeyer</H2>
<B>Meyer wavelet function. The fft_c.c file must be accessible.</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the continuous Meyer wavelet and scaling functions. Since Meyer wavelet has theoretically 
unlimited support, the function range has to be defined with [low, high].
</p><p>
For generating Meyer wavelets, an external C-function saved in fft_c.c file has to be called. This C-file has to 
be available in the current working directory or the searching path of Modelica must include the directory of fft_c.c file.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-8</TD><TD>Lower boundary of the function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>8</TD><TD>Higher boundary of the function</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Number of data points of the returned functions</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Real</TD><TD>phi[points]</TD><TD>Scaling function</TD></TR>
<TR><TD>Real</TD><TD>psi[points]</TD><TD>Wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavGaussian<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavGaussian"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavGaussian</H2>
<B>Gaussian wavelet function</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the continuous Gaussian wavelet function with the order up to 8. It has no scaling function. 
Since Gaussian wavelet has theoretically unlimited support, the function range has to be defined with [low, high].
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-5</TD><TD>Lower boundary of the function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>5</TD><TD>Higher boundary of the function</TD></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>1</TD><TD>Order of the derivative, &lt;=8</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Number of data points of the returned functions</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Real</TD><TD>psi[points]</TD><TD>Wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavMexHat<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavMexHat"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavMexHat</H2>
<B>Mexican hat wavelet function</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the continuous Mexican Hat wavelet function. It has no scaling function. 
Since Mexican Hat wavelet has theoretically unlimited support, the function range has to be defined with [low, high].
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-5</TD><TD>Lower boundary of the returned function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>5</TD><TD>Higher boundary of the returned function</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Number of the data points of the returned function</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Real</TD><TD>psi[points]</TD><TD>The wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavMorlet<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavMorlet"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavMorlet</H2>
<B>Morlet wavelet function</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the continuous Morlet wavelet function. It has no scaling function. 
Since Morlet wavelet has theoretically unlimited support, the function range has to be defined with [low, high].
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-4</TD><TD>Lower boundary of the function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>4</TD><TD>Higher boundary of the function</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Integer number, length of the returned functions</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Real</TD><TD>psi[points]</TD><TD>Wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavXGaussian<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavXGaussian"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavXGaussian</H2>
<B>Complex Gaussian wavelet function</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the complex Gaussian wavelet function with the order up to 8. It has no scaling function. 
Since complex Gaussian wavelet has theoretically unlimited support, the function range has to be defined with [low, high].
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-5</TD><TD>Lower boundary of the function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>5</TD><TD>Higher boundary of the function</TD></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>2</TD><TD>Order of the derivative, &lt;=8</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Number of data points of the returned functions</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Complex</TD><TD>psi[points]</TD><TD>Wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavXMorlet<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavXMorlet"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavXMorlet</H2>
<B>Complex Morlet wavelet function</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the complex Morlet wavelet function. It has no scaling function. 
Since complex Morlet wavelet has theoretically unlimited support, the function range has to be defined with [low, high].
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-4</TD><TD>Lower boundary of the function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>4</TD><TD>Higher boundary of the function</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Number of data points of the returned functions</TD></TR>
<TR><TD>Real</TD><TD>fb</TD><TD>1</TD><TD>Band width</TD></TR>
<TR><TD>Real</TD><TD>fc</TD><TD>1</TD><TD>Center frequency, e.g. 0.1, 0.5, 1, 1.5, ...</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Complex</TD><TD>psi[points]</TD><TD>Wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavXShannon<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavXShannon"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavXShannon</H2>
<B>Complex Shannon wavelet function</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the complex Shannon wavelet function. It has no scaling function. 
Since complex Shannon wavelet has theoretically unlimited support, the function range has to be defined with [low, high].
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-20</TD><TD>Lower boundary of the function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>20</TD><TD>Higher boundary of the function</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Number of data points of the returned functions</TD></TR>
<TR><TD>Real</TD><TD>fb</TD><TD>1</TD><TD>Band width, e.g. 1, 2</TD></TR>
<TR><TD>Real</TD><TD>fc</TD><TD>1</TD><TD>Center frequency, e.g. 0.1, 0.5, 1, 1.5, ...</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Complex</TD><TD>psi[points]</TD><TD>Wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavXFreqBSpline<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Families.wavXFreqBSpline"></A><A HREF="#Wavelet.Families"
>Wavelet.Families</A>.wavXFreqBSpline</H2>
<B>Complex Frequency B-Spline wavelet</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates the complex Frequency B-Spline wavelet function. It has no scaling function. 
Since this wavelet has theoretically unlimited support, the function range has to be defined with [low, high].
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-20</TD><TD>Lower boundary of the wavelet function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>20</TD><TD>Higher boundary of the wavelet function</TD></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>2</TD><TD>Wavelet order, a natural number, 1, 2, ...</TD></TR>
<TR><TD>Integer</TD><TD>points</TD><TD>32</TD><TD>Number of data points of the returned functions</TD></TR>
<TR><TD>Real</TD><TD>fb</TD><TD>1</TD><TD>Band width</TD></TR>
<TR><TD>Real</TD><TD>fc</TD><TD>1</TD><TD>Center frequency, a real number, e.g. 0.1, 0.5, 1, 1.5, ...</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[points]</TD><TD>Regular grid</TD></TR>
<TR><TD>Complex</TD><TD>psi[points]</TD><TD>Wavelet function</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE General<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.General</H2>
<B>General functions</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This section defines some general functions, which are common utilities for wavelet transformation and other functions.
</p>
<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General._fft" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General._fft"
>_fft</A>
</TD><TD>An external function to carry out FFT</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.cumSum" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.cumSum"
>cumSum</A>
</TD><TD>Cumulative sum of a vector. Data type is Real.</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.cumSumInt" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.cumSumInt"
>cumSumInt</A>
</TD><TD>Cumulative sum of a vector. Data type is Integer</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.diff" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.diff"
>diff</A>
</TD><TD>Difference between every two adjacent elements of a vector</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.fft" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.fft"
>fft</A>
</TD><TD>Fast Fourier transform</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.fftShift" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.fftShift"
>fftShift</A>
</TD><TD>Shift zero-frequency component to center of spectrum</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.findIndex" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.findIndex"
>findIndex</A>
</TD><TD>Find the location of a value in a monotone vector</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.filterBank" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.filterBank"
>filterBank</A>
</TD><TD>Get the four wavelet filters based on a given scaling filter</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.ifft" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.ifft"
>ifft</A>
</TD><TD>Inverse fast Fourier transform</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.innerProduct" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.innerProduct"
>innerProduct</A>
</TD><TD>Inner product of two same length vectors</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.interpL" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.interpL"
>interpL</A>
</TD><TD>One-dimensional linear interpolation</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.midVector" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.midVector"
>midVector</A>
</TD><TD>Extract the middle part of a vector</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.nStdIfft" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.nStdIfft"
>nStdIfft</A>
</TD><TD>Inverse non-standard 1-D fast Fourier transform</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.quadReverse" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.quadReverse"
>quadReverse</A>
</TD><TD>Quadrature mirror of a given vector</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.sinc" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.sinc"
>sinc</A>
</TD><TD>Sinc function</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.upsample" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.upsample"
>upsample</A>
</TD><TD>Up-sampling of a vector (insert a zero after every element except the last one)</TD></TR>
<TR><TD><IMG SRC="Wavelet.MRA.mraGUIS.png" ALT="Wavelet.General.wavConv" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.General.wavConv"
>wavConv</A>
</TD><TD>Fully convolving of a data vector and a filter vector for wavelet transform</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE _fft<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General._fft"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>._fft</H2>
<B>An external function to carry out FFT</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>dir</TD><TD>1</TD><TD>Calculation direction: 1 - forward; -1 - backward</TD></TR>
<TR><TD>Integer</TD><TD>m</TD><TD>3</TD><TD>Data points = 2^m</TD></TR>
<TR><TD>Real</TD><TD>x[:]</TD><TD>{i for i in 1:8}</TD><TD>Real part of the data</TD></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>{0,0,0,0,0,0,0,0}</TD><TD>Imaginary part of the data</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x_out[:]</TD><TD>Real part of the result</TD></TR>
<TR><TD>Real</TD><TD>y_out[:]</TD><TD>Imaginary part of the result</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cumSum<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.cumSum"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.cumSum</H2>
<B>Cumulative sum of a vector. Data type is Real.</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>i_v[:]</TD><TD>{1,2,3,4}</TD><TD>Input vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>o_v[size(i_v, 1)]</TD><TD>Output vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cumSumInt<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.cumSumInt"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.cumSumInt</H2>
<B>Cumulative sum of a vector. Data type is Integer</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>i_v[:]</TD><TD>{1,2,3,4}</TD><TD>Input vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>o_v[size(i_v, 1)]</TD><TD>Output vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE diff<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.diff"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.diff</H2>
<B>Difference between every two adjacent elements of a vector</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>in_v[:]</TD><TD>{1,2,3,4}</TD><TD>Input vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>out_v[size(in_v, 1) - 1]</TD><TD>Output vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fft<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.fft"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.fft</H2>
<B>Fast Fourier transform</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Complex</TD><TD>x[:]</TD><TD>{Complex(re=1, im=0),Complex...</TD><TD>The vector to be transformed</TD></TR>
<TR><TD>Integer</TD><TD>n</TD><TD>8</TD><TD>Number of data points to be calculated</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Complex</TD><TD>y[size(x, 1)]</TD><TD>The result</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fftShift<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.fftShift"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.fftShift</H2>
<B>Shift zero-frequency component to center of spectrum</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Complex</TD><TD>x[:]</TD><TD>&nbsp;</TD><TD>The vector to be shifted</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Complex</TD><TD>y[size(x, 1)]</TD><TD>The shifted vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE findIndex<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.findIndex"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.findIndex</H2>
<B>Find the location of a value in a monotone vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function searches the index of the input vector, u, according to x, so that:
</p><p>
If x is between u[k] and u[k+1], id1 = k and id2 = k+1.
</p><p>
If x is equal to u[k], id1 = id2 = k.
</p><p>
If x is smaller than all elements of u, id1 = id2 = 0.
</p><p>
If x is larger than all elements of u, id1 = id2 = size(u,1)+1.
</p><p>
The searching method is binary search, which has high efficiency for large searching spaces.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1,2,3,3,3,4,5,6,7,8}</TD><TD>A monotone vector, in which u[k+1] &gt;= u[k] for all k</TD></TR>
<TR><TD>Real</TD><TD>x</TD><TD>3</TD><TD>The value to be located in u</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>id1</TD><TD>The largest index, id1, so that u[id1] &lt;= x</TD></TR>
<TR><TD>Integer</TD><TD>id2</TD><TD>The smallest index, id2, so that u[id2] &gt;= x</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE filterBank<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.filterBank"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.filterBank</H2>
<B>Get the four wavelet filters based on a given scaling filter</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:]</TD><TD>{0.5,0.5}</TD><TD>The scaling filter</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>High pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>Low pass filter for reconstruction</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE ifft<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.ifft"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.ifft</H2>
<B>Inverse fast Fourier transform</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Complex</TD><TD>x[:]</TD><TD>{Complex(re=36, im=0),Comple...</TD><TD>The vector to be inverse transformed</TD></TR>
<TR><TD>Integer</TD><TD>n</TD><TD>8</TD><TD>Number of data points for calculation</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Complex</TD><TD>y[size(x, 1)]</TD><TD>The result</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE innerProduct<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.innerProduct"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.innerProduct</H2>
<B>Inner product of two same length vectors</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x1[:]</TD><TD>{1,2,3,4}</TD><TD>Vector 1</TD></TR>
<TR><TD>Real</TD><TD>x2[size(x1, 1)]</TD><TD>{1,2,3,4}</TD><TD>Vector 2</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y</TD><TD>Result</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE interpL<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.interpL"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.interpL</H2>
<B>One-dimensional linear interpolation</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function finds the values at u1 of the linearly interpolated function of the original data pairs, u and y. 
Both u and u1 must be monotone, meaning, e.g. u[k]>=u[k-1]. For the elements in u1 whose values are less than u[1], 
the corresponding elements in y1 are set as y[1]. For the elements in u1 whose values are greater than the last 
value of u, the corresponding elements in y1 are set as y[end]. 
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1,2,3,4}</TD><TD>The variable of the original data</TD></TR>
<TR><TD>Real</TD><TD>y[size(u, 1)]</TD><TD>{0,1,-1,2}</TD><TD>The function of the original data</TD></TR>
<TR><TD>Real</TD><TD>u1[:]</TD><TD>{0,0.5,1,1.5,2,2.5,3,3.5,4,4...</TD><TD>The variable of the interpolated function</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y1[size(u1, 1)]</TD><TD>The interpolated result at the variable values, u1[:]</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE midVector<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.midVector"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.midVector</H2>
<B>Extract the middle part of a vector</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[:]</TD><TD>{1,2,3,4,5,6}</TD><TD>Original vector</TD></TR>
<TR><TD>Integer</TD><TD>n</TD><TD>3</TD><TD>Number of the vector elements to be extracted</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:]</TD><TD>The result vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE nStdIfft<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.nStdIfft"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.nStdIfft</H2>
<B>Inverse non-standard 1-D fast Fourier transform</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Complex</TD><TD>xhat[:]</TD><TD>&nbsp;</TD><TD>The vector to be inverse transformed</TD></TR>
<TR><TD>Real</TD><TD>low</TD><TD>-8</TD><TD>Lower boundary of the function</TD></TR>
<TR><TD>Real</TD><TD>high</TD><TD>8</TD><TD>Higher boundary of the function</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(xhat, 1)]</TD><TD>The recovered signal</TD></TR>
<TR><TD>Real</TD><TD>t[size(xhat, 1)]</TD><TD>Time grid</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE quadReverse<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.quadReverse"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.quadReverse</H2>
<B>Quadrature mirror of a given vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Changes the signs of the even index entries of the reversed input vector, x, if p is true. 
If p is false the same holds for odd index entries.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[:]</TD><TD>{1,2,3,4,5,6,7,8}</TD><TD>Vector</TD></TR>
<TR><TD>Boolean</TD><TD>p</TD><TD>true</TD><TD>If p is true, the signs of the even index entries of the reversed input vector, x, is reversed. Otherwise, odd index entries are reversed.</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[size(x, 1)]</TD><TD>Quadrature mirrored elements of the input vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sinc<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.sinc"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.sinc</H2>
<B>Sinc function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x</TD><TD>pi/2</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y</TD><TD>&nbsp;</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE upsample<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.upsample"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.upsample</H2>
<B>Up-sampling of a vector (insert a zero after every element except the last one)</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1,2,3,4}</TD><TD>Input vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[size(u, 1)*2 - 1]</TD><TD>Output vector with the (double length of u) -1</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavConv<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.General.wavConv"></A><A HREF="#Wavelet.General"
>Wavelet.General</A>.wavConv</H2>
<B>Fully convolving of a data vector and a filter vector for wavelet transform</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>u[:]</TD><TD>{1,2,3,4}</TD><TD>The data vector</TD></TR>
<TR><TD>Real</TD><TD>f[:]</TD><TD>{1,2}</TD><TD>The filter vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[size(u, 1) + size(f, 1) - 1]</TD><TD>The filtered data vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Records<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Records"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.Records</H2>
<B>Records, mainly used for graphic user interface</B>
<P>
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Wavelet.Records.denoisParametersS.png" ALT="Wavelet.Records.denoisParameters" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Records.denoisParameters"
>denoisParameters</A>
</TD><TD>Parameters for 1D wavelet denoising</TD></TR>
<TR><TD><IMG SRC="Wavelet.Records.denoisParametersS.png" ALT="Wavelet.Records.mraParameters" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Records.mraParameters"
>mraParameters</A>
</TD><TD>Parameters for multi-resolution analysis (MRA)</TD></TR>
<TR><TD><IMG SRC="Wavelet.Records.wavFuncOutS.png" ALT="Wavelet.Records.wavFuncOut" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Records.wavFuncOut"
>wavFuncOut</A>
</TD><TD>Output data of function, wavFunc()</TD></TR>
<TR><TD><IMG SRC="Wavelet.Records.wavletDefinitionS.png" ALT="Wavelet.Records.wavletDefinition" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="#Wavelet.Records.wavletDefinition"
>wavletDefinition</A>
</TD><TD>Wavelet definition</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE denoisParameters<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Records.denoisParameters"></A><A HREF="#Wavelet.Records"
>Wavelet.Records</A>.denoisParameters</H2>
<B>Parameters for 1D wavelet denoising</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Parameters for carrying out wavelet denoising. 
</p>

<pre></PRE><P>
Extends from Modelica.Icons.Record (Icon for records).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>decLevel</TD><TD>2</TD><TD>Decomposition levels, &lt;=12</TD></TR>
<TR><TD><A HREF="#Wavelet.Types.threshMethod"
>threshMethod</A></TD><TD>thMethod</TD><TD>1</TD><TD>Select what method is to be used for calculating the threshold</TD></TR>
<TR><TD>Boolean</TD><TD>sorh</TD><TD>true</TD><TD>Soft (false) or hard (true) thresholding method</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Thresholds (&gt;=0) for all levels</TD></TR>
<TR><TD>Real</TD><TD>thD12</TD><TD>-1</TD><TD>Detail level 12</TD></TR>
<TR><TD>Real</TD><TD>thD11</TD><TD>-1</TD><TD>Detail level 11</TD></TR>
<TR><TD>Real</TD><TD>thD10</TD><TD>-1</TD><TD>Detail level 10</TD></TR>
<TR><TD>Real</TD><TD>thD9</TD><TD>-1</TD><TD>Detail level 9</TD></TR>
<TR><TD>Real</TD><TD>thD8</TD><TD>-1</TD><TD>Detail level 8</TD></TR>
<TR><TD>Real</TD><TD>thD7</TD><TD>-1</TD><TD>Detail level 7</TD></TR>
<TR><TD>Real</TD><TD>thD6</TD><TD>-1</TD><TD>Detail level 6</TD></TR>
<TR><TD>Real</TD><TD>thD5</TD><TD>-1</TD><TD>Detail level 5</TD></TR>
<TR><TD>Real</TD><TD>thD4</TD><TD>-1</TD><TD>Detail level 4</TD></TR>
<TR><TD>Real</TD><TD>thD3</TD><TD>-1</TD><TD>Detail level 3</TD></TR>
<TR><TD>Real</TD><TD>thD2</TD><TD>-1</TD><TD>Detail level 2</TD></TR>
<TR><TD>Real</TD><TD>thD1</TD><TD>-1</TD><TD>Detail level 1</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE mraParameters<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Records.mraParameters"></A><A HREF="#Wavelet.Records"
>Wavelet.Records</A>.mraParameters</H2>
<B>Parameters for multi-resolution analysis (MRA)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Parameters for carrying out wavelet multi-resolution analysis (MRA). 
</p>

<pre></PRE><P>
Extends from Modelica.Icons.Record (Icon for records).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Wavelet</TD></TR>
<TR><TD>Integer</TD><TD>decLevel</TD><TD>2</TD><TD>Decomposition levels, &lt;=12</TD></TR>
<TR><TD><A HREF="#Wavelet.Types.mraDisplay"
>mraDisplay</A></TD><TD>mraData</TD><TD>2</TD><TD>Select what data type is to be displayed in the decomposed levels</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Tuning factor of the coefficients before reconstruction. Levels higher than decLevel are omitted.</TD></TR>
<TR><TD>Real</TD><TD>rA</TD><TD>1</TD><TD>Approximating coefficients</TD></TR>
<TR><TD>Real</TD><TD>rD12</TD><TD>1</TD><TD>Detail coefficients, level 12</TD></TR>
<TR><TD>Real</TD><TD>rD11</TD><TD>1</TD><TD>Detail coefficients, level 11</TD></TR>
<TR><TD>Real</TD><TD>rD10</TD><TD>1</TD><TD>Detail coefficients, level 10</TD></TR>
<TR><TD>Real</TD><TD>rD9</TD><TD>1</TD><TD>Detail coefficients, level 9</TD></TR>
<TR><TD>Real</TD><TD>rD8</TD><TD>1</TD><TD>Detail coefficients, level 8</TD></TR>
<TR><TD>Real</TD><TD>rD7</TD><TD>1</TD><TD>Detail coefficients, level 7</TD></TR>
<TR><TD>Real</TD><TD>rD6</TD><TD>1</TD><TD>Detail coefficients, level 6</TD></TR>
<TR><TD>Real</TD><TD>rD5</TD><TD>1</TD><TD>Detail coefficients, level 5</TD></TR>
<TR><TD>Real</TD><TD>rD4</TD><TD>1</TD><TD>Detail coefficients, level 4</TD></TR>
<TR><TD>Real</TD><TD>rD3</TD><TD>1</TD><TD>Detail coefficients, level 3</TD></TR>
<TR><TD>Real</TD><TD>rD2</TD><TD>1</TD><TD>Detail coefficients, level 2</TD></TR>
<TR><TD>Real</TD><TD>rD1</TD><TD>1</TD><TD>Detail coefficients, level 1</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavFuncOut<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Records.wavFuncOut"></A><A HREF="#Wavelet.Records"
>Wavelet.Records</A>.wavFuncOut</H2>
<B>Output data of function, wavFunc()</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Output parameters of function <A HREF="#Wavelet.Families.wavFunc"
>wavFunc()</a>.
</p>

<pre></PRE><P>

<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Output</TD></TR>
<TR><TD>String</TD><TD>wavName</TD><TD>&nbsp;</TD><TD>Wavelet name</TD></TR>
<TR><TD>Integer</TD><TD>wavType</TD><TD>&nbsp;</TD><TD>Wavelet type: 1. orthogonal wavelets; 2. biorthogonal wavelets; 
    3. wavelet with scaling function; 4. wavelet without scaling function; 5. complex wavelet without scaling function</TD></TR>
<TR><TD>Real</TD><TD>F1[:]</TD><TD>&nbsp;</TD><TD>Orthogonal wavelets: scaling filter; biorthogonal wavelets: scaling filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>F2[:]</TD><TD>&nbsp;</TD><TD>Only for biorthogonal wavelets: scaling filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>lod[:]</TD><TD>&nbsp;</TD><TD>Low pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>hid[:]</TD><TD>&nbsp;</TD><TD>High pass filter for decomposition</TD></TR>
<TR><TD>Real</TD><TD>lor[:]</TD><TD>&nbsp;</TD><TD>Low pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>hir[:]</TD><TD>&nbsp;</TD><TD>High pass filter for reconstruction</TD></TR>
<TR><TD>Real</TD><TD>x[:]</TD><TD>&nbsp;</TD><TD>Equidistance grid</TD></TR>
<TR><TD>Real</TD><TD>phi1[:]</TD><TD>&nbsp;</TD><TD>Scaling functions</TD></TR>
<TR><TD>Real</TD><TD>psi1[:]</TD><TD>&nbsp;</TD><TD>Wavelet functions</TD></TR>
<TR><TD>Real</TD><TD>phi2[:]</TD><TD>&nbsp;</TD><TD>Scaling functions, only applicable for biorthogonal wavelets</TD></TR>
<TR><TD>Real</TD><TD>psi2[:]</TD><TD>&nbsp;</TD><TD>Wavelet functions, only applicable for biorthogonal wavelets</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavletDefinition<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Records.wavletDefinition"></A><A HREF="#Wavelet.Records"
>Wavelet.Records</A>.wavletDefinition</H2>
<B>Wavelet definition</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Parameters for wavelet definition. 
</p>
<p>
Refer to the section of wavelet <A HREF="#Wavelet.Families"
>Families</a> 
for detailed information about the available wavelets.

</p>

<pre></PRE><P>
Extends from Modelica.Icons.Record (Icon for records).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Input</TD></TR>
<TR><TD><A HREF="#Wavelet.Types.wavletID"
>wavletID</A></TD><TD>wavID</TD><TD>2</TD><TD>ID number of the wavelet family to be displayed, 1..15.</TD></TR>
<TR><TD>Integer</TD><TD>Nd</TD><TD>3</TD><TD>Wavelet order</TD></TR>
<TR><TD>Integer</TD><TD>Nr</TD><TD>3</TD><TD>Wavelet order for reconstruction, only used for biorthogonal wavelets</TD></TR>
<TR><TD>Real</TD><TD>fb</TD><TD>1.0</TD><TD>Bandwidth frequency, only for complex wavelets</TD></TR>
<TR><TD>Real</TD><TD>fc</TD><TD>1.0</TD><TD>Center frequency, only for complex wavelets</TD></TR>
<TR><TD>Real</TD><TD>range</TD><TD>5.0</TD><TD>Boundary of the wavelet and scaling functions, [-range, range]. Valid for wavelets with theoretically unlimited support. Effective support is used as default value if range==0</TD></TR>
<TR><TD>Integer</TD><TD>refinement</TD><TD>6</TD><TD>Refinement of the estimated wavelet and scaling functions. 
    For orthogonal and biorthogonal wavelets, it stands for the iteration 
    times to generating functions. The returned function length is (filter_length-1)*2^refinement+1. 
    For other wavelets, the length of the returned functions is 2^refinement.</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Types<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Types"></A><A HREF="Wavelet.html#Wavelet"
>Wavelet</A>.Types</H2>
<B>Definitions of enumeration values</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>Enumeration variables are defined here. 

<h4><font color="#008000">waveletID: ID numbers of wavelets</font></h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>waveletID</b></td>
      <td><b>Wavelet name</b></td>
      </tr>
  
  <tr><td>1</td> <td>Haar</td> </tr>
  <tr><td>2</td> <td>Daubechies</td> </tr>
  <tr><td>3</td> <td>Symlets</td> </tr>
  <tr><td>4</td> <td>Coiflets</td> </tr>
  <tr><td>5</td> <td>Biorthogonal spline</td> </tr>
  <tr><td>6</td> <td>Reverse biorthogonal spline</td> </tr>
  <tr><td>7</td> <td>Meyer</td> </tr>
  <tr><td>8</td> <td>Discrete Meyer</td> </tr>
  <tr><td>9</td> <td>Gaussian</td> </tr>
  <tr><td>10</td> <td>Mexican hat</td> </tr>
  <tr><td>11</td> <td>Morlet</td> </tr>
  <tr><td>12</td> <td>Complex Gaussian</td> </tr>
  <tr><td>13</td> <td>Complex Morlet</td> </tr>
  <tr><td>14</td> <td>Complex Shannon</td> </tr>
  <tr><td>15</td> <td>Complex frequency B-Spline</td> </tr>
  
</table>

<h4><font color="#008000">mraDisplay: Data type to be displayed in MRA</font></h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>Value</b></td>
      <td><b>Name</b></td>
      <td><b>Description</b></td>
      </tr>
  
  <tr><td>1</td> <td>coefficients</td> <td>Wavelet coefficients</td> </tr>
  <tr><td>2</td> <td>signal</td> <td>Reconstructed signal</td> </tr>
  
</table>

<h4><font color="#008000">threshID: ID numbers of different methods for threshold calculation for denoising</font></h4>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>Value</b></td>
      <td><b>Name</b></td>
      <td><b>Description</b></td>
      </tr>
  
  <tr><td>1</td> <td>fixedForm</td> <td>Fixed form threshold. Threshold value = sqrt(2*ln(N)), with N being the length of the data to be denoised.</td> </tr>
  <tr><td>2</td> <td>SURE</td> <td>The threshold is calculated using the principle of Stein's Unbiased Risk Estimate(SURE). </td> </tr>
  <tr><td>3</td> <td>heurSure</td> <td>Heuristic SURE method. It is a combination of fixedForm and SURE methods. The noise level is firstly tested. 
  For a high signal-to-noise ratio, SURE method is used, otherwise fixedForm method is used. </td> </tr>
  <tr><td>4</td> <td>miniMax</td> <td>The threshold is calculated according to the miniMax principle, which realizes the minimum of the maximum mean square error.</td> </tr>
    
</table>
    
</p>
<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="#Wavelet.Types.mraDisplay"
>mraDisplay</A>
</TD><TD>Selection of display data for MRA: 1 - wavelet coefficients; 2 - reconstructed signal</TD></TR>
<TR><TD><A HREF="#Wavelet.Types.threshMethod"
>threshMethod</A>
</TD><TD>Methods for calculating threshold for denoising: 1 - fixed form; 2 - SURE method; 
  3 - heuristic SURE; 4 - minimal maximum method</TD></TR>
<TR><TD><A HREF="#Wavelet.Types.wavletID"
>wavletID</A>
</TD><TD>Definition of wavelet identifiers: 1 - Haar; 2 - Daubechies; 3 - Symlets; 4 - Coiflets; 
  5 - Biorthogonal spline; 6 - Reverse biorthogonal spline; 7 - Meyer; 8 - Discrete Meyer; 9 - Gaussian; 10 - Mexican hat; 
  11 - Morlet; 12 - Complex Gaussian; 13 - Complex Morlet; 14 - Complex Shannon; 15 - Complex frequency B-Spline</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE mraDisplay<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Types.mraDisplay"></A><A HREF="#Wavelet.Types"
>Wavelet.Types</A>.mraDisplay</H2>
<B>Selection of display data for MRA: 1 - wavelet coefficients; 2 - reconstructed signal</B><p>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE threshMethod<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Types.threshMethod"></A><A HREF="#Wavelet.Types"
>Wavelet.Types</A>.threshMethod</H2>
<B>Methods for calculating threshold for denoising: 1 - fixed form; 2 - SURE method; 
  3 - heuristic SURE; 4 - minimal maximum method</B><p>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wavletID<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Wavelet.Types.wavletID"></A><A HREF="#Wavelet.Types"
>Wavelet.Types</A>.wavletID</H2>
<B>Definition of wavelet identifiers: 1 - Haar; 2 - Daubechies; 3 - Symlets; 4 - Coiflets; 
  5 - Biorthogonal spline; 6 - Reverse biorthogonal spline; 7 - Meyer; 8 - Discrete Meyer; 9 - Gaussian; 10 - Mexican hat; 
  11 - Morlet; 12 - Complex Gaussian; 13 - Complex Morlet; 14 - Complex Shannon; 15 - Complex frequency B-Spline</B><p>
<HR>
<address><a href="http://www.3ds.com/">Automatically generated</a> Tue Nov 26 14:52:03 2013.
</address></BODY>
</HTML>
